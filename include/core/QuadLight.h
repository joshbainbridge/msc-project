#ifndef _QUADLIGHT_H_
#define _QUADLIGHT_H_

#include <core/Common.h>
#include <core/LightInterface.h>

MSC_NAMESPACE_BEGIN

/**
 * @brief      Inherits from the light interface and represents a quad light surface
 */
class QuadLight : public LightInterface
{
public:
  QuadLight()
    : m_translation(Vector3f(0.f, 0.f, 0.f))
    , m_rotation(Vector3f(0.f, 0.f, 0.f))
    , m_scale(Vector3f(1.f, 1.f, 1.f))
    , m_radiance(100.f)
  {;}

  /**
   * @brief      Getter method for translation
   *
   * @return     translation vector
   */
  inline Vector3f translation() const {return m_translation;}

  /**
   * @brief      Getter method for rotation
   *
   * @return     euler angle vector
   */
  inline Vector3f rotation() const {return m_rotation;}

  /**
   * @brief      Getter method for scale
   *
   * @return     scale vector
   */
  inline Vector3f scale() const {return m_scale;}

  /**
   * @brief      Getter method for light radiance
   *
   * @return     radiance
   */
  inline float radiance() const {return m_radiance;}

  /**
   * @brief      Setter method for translation
   *
   * @param[in]  _translation  translation vector
   */
  void translation(const Vector3f &_translation){m_translation = _translation;}

  /**
   * @brief      Setter method for rotation
   *
   * @param[in]  _translation  euler angle vector
   */
  void rotation(const Vector3f &_rotation){m_rotation = _rotation;}

  /**
   * @brief      Setter method for scale
   *
   * @param[in]  _translation  scale vector
   */
  void scale(const Vector3f &_scale){m_scale = _scale;}

  /**
   * @brief      Setter method for light radiance
   *
   * @param[in]  _translation  radiance
   */
  void radiance(const float _radiance){m_radiance = _radiance;}

  /**
   * @brief      Illumination of mulitple positions on a geometric surface
   *
   * @param[in]  <unnamed>  amount of positions to be illuminated
   * @param      _random    thread local random generator to prevent mutation
   * @param      _position  array of position data
   * @param      _input     array of input directions generated by light for surface evaluation
   * @param      _radiance  array of radiance values for surface postions
   */
  void illuminate(const unsigned int _size, RandomGenerator* _random, Vector3f* _position, Vector3f* _input, Colour3f* _radiance) const;

private:
  Vector3f m_translation;
  Vector3f m_rotation;
  Vector3f m_scale;
  float m_radiance;
};

MSC_NAMESPACE_END

YAML_NAMESPACE_BEGIN

template<> struct convert<msc::QuadLight>
{
  static Node encode(const msc::QuadLight& rhs)
  {
    Node node;
    node["light"]["type"] = "Quad";
    node["light"]["translation"] = rhs.translation();
    node["light"]["rotation"] = rhs.rotation();
    node["light"]["scale"] = rhs.scale();
    node["light"]["radiance"] = rhs.radiance();
    return node;
  }

  static bool decode(const Node& node, msc::QuadLight& rhs)
  {
    if(!node.IsMap() || node.size() != 5)
      return false;

    rhs.translation(node["translation"].as<msc::Vector3f>());
    rhs.rotation(node["rotation"].as<msc::Vector3f>());
    rhs.scale(node["scale"].as<msc::Vector3f>());
    rhs.radiance(node["radiance"].as<float>());
    return true;
  }
};

YAML_NAMESPACE_END

#endif
