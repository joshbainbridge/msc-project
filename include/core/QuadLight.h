#ifndef _QUADLIGHT_H_
#define _QUADLIGHT_H_

#include <core/Common.h>
#include <core/LightInterface.h>

MSC_NAMESPACE_BEGIN

/**
 * @brief      Inherits from the light interface and represents a quad light surface
 * 
 * This represent a physically based quad light that can evaluate a point in space
 * as well as sample it's surface and return the probaility density in respect to area.
 */
class QuadLight : public LightInterface
{
public:
  /**
   * @brief      Initialiser list for class
   */
  QuadLight()
    : m_translation(Vector3f(0.f, 0.f, 0.f))
    , m_rotation(Vector3f(0.f, 0.f, 0.f))
    , m_scale(Vector2f(1.f, 1.f))
    , m_intensity(100.f)
  {;}

  /**
   * @brief      Getter method for translation
   *
   * @return     translation vector
   */
  inline Vector3f translation() const {return m_translation;}

  /**
   * @brief      Getter method for rotation
   *
   * @return     euler angle vector
   */
  inline Vector3f rotation() const {return m_rotation;}

  /**
   * @brief      Getter method for scale
   *
   * @return     scale vector
   */
  inline Vector2f scale() const {return m_scale;}

  /**
   * @brief      Getter method for light intensity
   *
   * @return     intensity
   */
  inline float intensity() const {return m_intensity;}

  /**
   * @brief      Get reference to geometry positions
   *
   * @return     positions reference
   */
  inline std::vector<float>& positions() {return m_positions;}

  /**
   * @brief      Get reference to geometry indices
   *
   * @return     indices reference
   */
  inline std::vector<unsigned int>& indices() {return m_indices;}

  /**
   * @brief      Setter method for translation
   *
   * @param[in]  _translation  translation vector
   */
  void translation(const Vector3f &_translation){m_translation = _translation;}

  /**
   * @brief      Setter method for rotation
   *
   * @param[in]  _translation  euler angle vector
   */
  void rotation(const Vector3f &_rotation){m_rotation = _rotation;}

  /**
   * @brief      Setter method for scale
   *
   * @param[in]  _translation  scale vector
   */
  void scale(const Vector2f &_scale){m_scale = _scale;}

  /**
   * @brief      Setter method for light intensity
   *
   * @param[in]  _translation  intensity
   */
  void intensity(const float _intensity){m_intensity = _intensity;}

  /**
   * @brief      Precomputes transform and geometry information
   */
  void construct();

  /**
   * @brief      Illumination of mulitple positions on a geometric surface
   *
   * @param      _random      thread local random generator to prevent mutation
   * @param      _position    position data
   * @param      _direction   input directions generated by light for surface evaluation
   * @param      _distance    distance between light sample and surface position
   * @param      _radiance    radiance values for surface postions
   * @param      _direct_pdfw probabilty in respect to solid angle
   */
  void illuminate(
    RandomGenerator* _random,
    const Vector3f& _position,
    Vector3f* _direction,
    float* _distance,
    Colour3f* _radiance,
    float* _direct_pdfw = NULL
    ) const;

  /**
   * @brief      Radiance on light in direction towards surface
   *
   * @param[in]  _direction    input direction to be evaluated
   * @param      _radiance     radiance value
   * @param      _direct_pdfa  probability in respect to surface area
   */
  void radiance(
    const Vector3f& _direction,
    Colour3f* _radiance,
    float* _cos_theta,
    float* _direct_pdfa = NULL
    ) const;

private:
  Vector3f m_translation;
  Vector3f m_rotation;
  Vector2f m_scale;
  float m_intensity;

  Affine3f m_transform;
  Vector3f m_normal;

  std::vector< float > m_positions;
  std::vector< unsigned int > m_indices;
};

MSC_NAMESPACE_END

YAML_NAMESPACE_BEGIN

template<> struct convert<msc::QuadLight>
{
  static bool decode(const Node& node, msc::QuadLight& rhs)
  {
    if(!node.IsMap() || node.size() != 5)
      return false;

    rhs.translation(node["translation"].as<msc::Vector3f>());
    rhs.rotation(node["rotation"].as<msc::Vector3f>());
    rhs.scale(node["scale"].as<msc::Vector2f>());
    rhs.intensity(node["intensity"].as<float>());

    rhs.construct();

    return true;
  }
};

YAML_NAMESPACE_END

#endif
